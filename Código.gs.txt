// --- CONFIGURA√á√ÉO GLOBAL ---
// OBRIGAT√ìRIO: Este bloco deve estar no topo do arquivo,
// fora de qualquer fun√ß√£o, para que todos os m√≥dulos o acessem.
const CONFIG = { 
  sheets: {
    prescricao: "Prescri√ß√£o de Doses",
    peso: "Registro de Peso",
    pacientes: "Pacientes", // Aba com Nome e Prontu√°rio
    tabelaResumo: "MENU PRINCIPAL",  // Aba com dados consolidados
    exames: "Exames",
    examesRef: "Exames_Referencia",
    ramTab: "FARMACOVIGIL√ÇNCIA" // <-- O nome da sua nova aba
  },
  headers: {
    // Cabe√ßalhos da aba 'Pacientes'
    nomePaciente: "PACIENTE",
    prontuario: "PRONTU√ÅRIO", // CR√çTICO: Verifique se o acento est√° correto na sua planilha
    dataNascimento: "DATA_NASCIMENTO", // <-- IMPORTANTE: CONFIRME ESTE NOME
    gestacao: "IDADE GESTACIONAL",
    sexo: "SEXO",
    ramTipo: "RAM", // A coluna com o tipo/categoria da RAM
    ramData: "DATA_RAM", // (NOVA COLUNA NECESS√ÅRIA para an√°lise temporal)
    ramGravidade: "GRAVIDADE",
    ramDesfecho: "DESFECHO",
    idEventoRam: "ID_EVENTO_RAM",       // Na aba 'TABELA'
    causalidadeRam: "CAUSALIDADE_RAM", // Na aba 'TABELA'

    // Cabe√ßalhos da aba 'Prescri√ß√£o de Doses'
    dataInicio: "DATA_INICIO",
    dataFim: "DATA_FIM", // Coluna necess√°ria para calcular dias de tratamento
    fabricante: "FABRICANTE", // Sua nova coluna de "Marca"
    medicamento: "MEDICAMENTO",
    doseAdministrada: "DOSE_ADMINISTRADA_mg",
    
    colPesoReferencia: "PESO_REFERENCIA_kg",
    colTaxaResultante: "TAXA_RESULTANTE_mg_kg",
    sexo: "SEXO",
    classificacao: "Classifica√ß√£o Prematuridade",
    exameData: "DATA_EXAME",
    exameNome: "NOME_EXAME",
    exameValor: "VALOR_RESULTADO",
    exameAnalise: "AN√ÅLISE",
    exameRefMin: "REF_MIN",
    exameRefMax: "REF_MAX",

    // Cabe√ßalho da aba 'Registro de Peso'
    dataPeso: "DATA_AFERICAO",
    peso: "PESO_kg",

    // Cabe√ßalhos da aba 'Tabela' (resumo)
    // Verifique se os nomes das colunas na sua aba 'Tabela' batem exatamente com os do PDF/CONFIG
    analiseClassificacao: "AN√ÅLISE DE MUDAN√áA (1¬™ -> 2¬™ TAXA)",
    custoTotal: "CUSTO TOTAL TRATAMENTO PCTE", // O PDF tem "CUSTO TOTAL AMPOLAS TRATAMENTO PCTE", verifique qual est√° na sua aba
    duracaoTratamento: "TRATAMENTO (DIAS)",
    conclusoes: "CONCLUS√ïES",
    idadeGestacional: "IDADE GESTACIONAL + PER√çODO DE TRATAMENTO", // Adicionado para relat√≥rio

    // Cabe√ßalhos da aba 'Exames_Referencia'
    exameRefNome: "NOME_EXAME",
    exameRefTipo: "TIPO_REGRA", // "Padr√£o" ou "Prematuro Espec√≠fico"
    exameRefMinDias: "IDADE_MIN_DIAS",
    exameRefMaxDias: "IDADE_MAX_DIAS",
    exameRefMinValor: "VALOR_MIN",
    exameRefMaxValor: "VALOR_MAX"
  }
};

const MASTER_DB_SHEET_ID = "1zKqYVR9seTPy3eyX5CR2xuXZtqSwwvERQn_KX3GK5JM"

// --- M√ìDULO 1: C√ÅLCULO AUTOM√ÅTICO DE TAXA (onEdit) ---
// (Esta fun√ß√£o permanece inalterada)
function onEdit(e) {
  if (!e || !e.range) return; // Sai se for uma edi√ß√£o inv√°lida

  const planilha = e.source.getActiveSheet();
  const celulaEditada = e.range;
  // Verifica se a edi√ß√£o foi na aba correta e n√£o no cabe√ßalho
  if (planilha.getName() !== CONFIG.sheets.prescricao || celulaEditada.getRow() <= 1) return;
  const cabecalhos = planilha.getRange(1, 1, 1, planilha.getLastColumn()).getValues()[0];
  const indices = {
    prontuario: cabecalhos.indexOf(CONFIG.headers.prontuario),
    dataInicio: cabecalhos.indexOf(CONFIG.headers.dataInicio),
    doseAdministrada: cabecalhos.indexOf(CONFIG.headers.doseAdministrada),
    pesoReferencia: cabecalhos.indexOf(CONFIG.headers.colPesoReferencia),
    taxaResultante: cabecalhos.indexOf(CONFIG.headers.colTaxaResultante)
  };
  // Verifica se todos os cabe√ßalhos necess√°rios foram encontrados
  if (Object.values(indices).some(index => index === -1)) {
    Logger.log("Erro no onEdit: N√£o foi poss√≠vel encontrar um ou mais cabe√ßalhos na aba '" + CONFIG.sheets.prescricao + "'. Verifique CONFIG.headers: " + JSON.stringify(indices));
    return;
  }

  // Verifica se a c√©lula editada foi a coluna de dose
  if (celulaEditada.getColumn() !== indices.doseAdministrada + 1) return;
  const linhaEditada = celulaEditada.getRow();
  Logger.log(`onEdit: Editado na linha ${linhaEditada} da aba '${CONFIG.sheets.prescricao}'`);

  const prontuario = planilha.getRange(linhaEditada, indices.prontuario + 1).getValue();
  let dataInicio;
  let doseAdministrada;

  try {
    const dataValor = planilha.getRange(linhaEditada, indices.dataInicio + 1).getValue();
    if (!dataValor) throw new Error("Data de in√≠cio vazia");
    dataInicio = new Date(dataValor);
    if (isNaN(dataInicio.getTime())) throw new Error("Formato de data inv√°lido: " + dataValor);

    const doseValor = planilha.getRange(linhaEditada, indices.doseAdministrada + 1).getValue();
    if (doseValor === "" || doseValor === null || isNaN(Number(doseValor))) {
      // Se a dose for apagada, limpa os campos calculados
      planilha.getRange(linhaEditada, indices.taxaResultante + 1).clearContent().clearNote();
      planilha.getRange(linhaEditada, indices.pesoReferencia + 1).clearContent();
      return;
    }
    doseAdministrada = Number(doseValor);
  } catch (err) {
    Logger.log("Erro ao obter dados da linha " + linhaEditada + ": " + err.message);
    planilha.getRange(linhaEditada, indices.taxaResultante + 1).setValue("ERRO: " + err.message).clearNote();
    planilha.getRange(linhaEditada, indices.pesoReferencia + 1).setValue("");
    return;
  }

  if (!prontuario) {
    Logger.log("Prontu√°rio vazio na linha " + linhaEditada);
    planilha.getRange(linhaEditada, indices.taxaResultante + 1).setValue("Falta Prontu√°rio").clearNote();
    planilha.getRange(linhaEditada, indices.pesoReferencia + 1).setValue("");
    return;
  }

  // Otimiza√ß√£o: Usa o mapa de pesos em cache
  const pesoMaisRecente = findLatestWeightOptimized(prontuario, dataInicio);
  if (pesoMaisRecente !== null && typeof pesoMaisRecente === 'number' && pesoMaisRecente > 0) {
    const taxaResultante = doseAdministrada / pesoMaisRecente;
    planilha.getRange(linhaEditada, indices.pesoReferencia + 1).setValue(pesoMaisRecente).setNumberFormat("0.000");
    planilha.getRange(linhaEditada, indices.taxaResultante + 1).setValue(taxaResultante).setNumberFormat("0.00").clearNote();
    Logger.log(`onEdit: Linha ${linhaEditada}, Prontu√°rio ${prontuario}, Data ${dataInicio.toLocaleDateString()}, Dose ${doseAdministrada}, Peso ${pesoMaisRecente}, Taxa ${taxaResultante.toFixed(2)}`);
  } else {
    planilha.getRange(linhaEditada, indices.taxaResultante + 1).setValue("Peso n√£o encontrado").setNote(`Nenhum peso encontrado para ${prontuario} em ou antes de ${dataInicio.toLocaleDateString()}`);
    planilha.getRange(linhaEditada, indices.pesoReferencia + 1).setValue(""); // Limpa o peso de refer√™ncia
    Logger.log("Peso n√£o encontrado para prontu√°rio " + prontuario + " em ou antes de " + dataInicio.toLocaleDateString());
  }
}

/**
 * =============================================================
 * M√ìDULO PRINCIPAL (C√≥digo.gs)
 * (vX - Menu 'onOpen' Refatorado para M√≥dulos Cl√≠nicos)
 * =============================================================
 */

/**
 * Cria o menu principal da ferramenta
 * (v-Wizard - Organizado com o "Wizard" de Setup no topo)
 */
function onOpen(e) {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('üî¨ An√°lise EUM')
    
    // 1. O NOVO "BOT√ÉO INICIAL"
    .addItem('üöÄ Iniciar/Configurar Novo EUM', 'abrirWizardBoasVindas')
    .addSeparator()

    // 2. Acesso R√°pido
    .addItem('üë§ Ver Prontu√°rio do Paciente', 'abrirSidebarAnalise')
    .addSeparator()

    // 3. M√≥dulo de Exames
    .addSubMenu(ui.createMenu('üß™ Exames')
        .addItem('Processar An√°lise de Exames', 'processarAnaliseExames')
        .addItem('An√°lise de Tend√™ncia (Interativa)', 'abrirModalAnaliseMedicamento')
     )

    // 4. M√≥dulo de Farmacovigil√¢ncia (RAMs)
    .addSubMenu(ui.createMenu('üõ°Ô∏è Farmacovigil√¢ncia (RAMs)')
        .addItem('Avaliar Causalidade de RAM (Naranjo)', 'abrirSidebarAvaliacao_UI')
        .addItem('Gerar Relat√≥rio de RAMs', 'abrirModalAnaliseRAM')
     )

    // 5. M√≥dulo de Relat√≥rios Gerais / Protocolos
    .addSubMenu(ui.createMenu('üìä Relat√≥rios & Protocolos')
        .addItem('Analisar Ades√£o ao Protocolo', 'abrirModalAnaliseProtocolo')
        .addItem('Gerar Relat√≥rio Modular (Est√°tico)', 'abrirModalRelatorioBuilder')
     )
     
    // 6. M√ìDULO DE FARMACOECONOMIA
    .addSubMenu(ui.createMenu('üí∞ Farmacoeconomia')
        .addItem('An√°lise de Custo-Efetividade (Wizard)', 'abrirModalCustoEfetividade')
     )
    
    // (O submenu 'Sistema' foi removido pois suas fun√ß√µes est√£o agora no Wizard)
    
    .addSeparator()
    .addItem('‚ö†Ô∏è Lembrete', 'mostrarLembrete')
    .addToUi();
}

/**
 * Fun√ß√£o de lembrete adicionada ao menu
 * (v2 - ATUALIZADA para o novo fluxo de RAMs)
 */
function mostrarLembrete() {
  SpreadsheetApp.getUi().alert(
    'Lembretes R√°pidos da Ferramenta:',
    '1. Para usar o "Ver Prontu√°rio": Clique em qualquer linha de paciente na aba "TABELA" ou "Exames".\n\n' +
    '2. Para usar o "Avaliar Causalidade": Clique em qualquer linha de RAM na aba "FARMACOVIGIL√ÇNCIA".\n\n' +
    '3. Antes de rodar "Processar An√°lise de Exames", use o menu "Configura√ß√£o" para importar as regras e configurar a aba.',
    SpreadsheetApp.getUi().ButtonSet.OK
  );
}

/**
 * Mostra a sidebar na interface do usu√°rio.
 * (Esta fun√ß√£o permanece inalterada)
 */
function abrirSidebarAnalise() {
  const html = HtmlService.createHtmlOutputFromFile('SidebarPaciente')
    .setTitle('Perfil do Paciente');
  SpreadsheetApp.getUi().showSidebar(html);
}


// --- M√ìDULO 3 & 4: PROCESSADOR EM LOTE E ANALISADOR DE PROTOCOLO ---

/**
 * Fun√ß√£o principal do processador.
 * Chamada pelo menu "Processar Planilha Inteira".
 * Varre a aba 'Prescri√ß√£o de Doses' e preenche taxas.
 * Atualiza a coluna de an√°lise na aba 'Tabela'.
 * (Esta fun√ß√£o permanece inalterada)
 */
function processarPlanilhaInteira() {
  const ui = SpreadsheetApp.getUi();
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000); // Tenta obter o bloqueio por at√© 30 segundos
  } catch (e) {
    ui.alert('Outro processo j√° est√° em execu√ß√£o. Por favor, aguarde alguns instantes e tente novamente.');
    Logger.log('N√£o foi poss√≠vel obter o bloqueio para processar: ' + e);
    return;
  }

  Logger.log("Iniciando 'processarPlanilhaInteira'...");
  let modalHtml = HtmlService.createHtmlOutput('<p>Processando dados...<br>Calculando taxas e analisando mudan√ßas de dose.<br>Por favor, aguarde.</p>').setWidth(350).setHeight(120);
  ui.showModalDialog(modalHtml, 'Processamento em Andamento');
  SpreadsheetApp.flush(); // Garante que a UI seja atualizada

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const prescricaoSheet = ss.getSheetByName(CONFIG.sheets.prescricao);
    const pesoSheet = ss.getSheetByName(CONFIG.sheets.peso); // Usado pelo `findLatestWeightOptimized`
    const tabelaResumoSheet = ss.getSheetByName(CONFIG.sheets.tabelaResumo);
    if (!prescricaoSheet) {
      throw new Error('Aba "' + CONFIG.sheets.prescricao + '" n√£o encontrada.');
    }
    if (!pesoSheet) {
      Logger.log('Aviso: Aba "' + CONFIG.sheets.peso + '" n√£o encontrada. N√£o ser√° poss√≠vel calcular taxas baseadas em peso.');
    }
    if (!tabelaResumoSheet) {
      Logger.log('Aviso: Aba "' + CONFIG.sheets.tabelaResumo + '" n√£o encontrada. A an√°lise de mudan√ßa de dose n√£o poder√° ser salva nela.');
    }

    // Pega todos os dados de uma vez
    const prescricaoRange = prescricaoSheet.getDataRange();
    const prescricaoData = prescricaoRange.getValues();
    const tabelaResumoData = tabelaResumoSheet ? tabelaResumoSheet.getDataRange().getValues() : [];
    // Identifica colunas na aba Prescri√ß√£o
    const cabecalhosPresc = prescricaoData[0];
    const idxProntuarioPresc = cabecalhosPresc.indexOf(CONFIG.headers.prontuario);
    const idxDataInicioPresc = cabecalhosPresc.indexOf(CONFIG.headers.dataInicio);
    const idxDosePresc = cabecalhosPresc.indexOf(CONFIG.headers.doseAdministrada);
    const idxPesoRefPresc = cabecalhosPresc.indexOf(CONFIG.headers.colPesoReferencia);
    const idxTaxaPresc = cabecalhosPresc.indexOf(CONFIG.headers.colTaxaResultante);
    // Identifica colunas na aba Tabela (para salvar a an√°lise)
    let idxProntuarioTabela = -1;
    let idxAnaliseTabela = -1;
    if (tabelaResumoSheet && tabelaResumoData.length > 0) {
      const cabecalhosTabela = tabelaResumoData[0];
      idxProntuarioTabela = cabecalhosTabela.indexOf(CONFIG.headers.prontuario);
      idxAnaliseTabela = cabecalhosTabela.indexOf(CONFIG.headers.analiseClassificacao);
      if (idxProntuarioTabela === -1 || idxAnaliseTabela === -1) {
        Logger.log("Aviso: Colunas '" + CONFIG.headers.prontuario + "' ou '" + CONFIG.headers.analiseClassificacao + "' n√£o encontradas na aba 'Tabela'. A an√°lise n√£o ser√° salva l√°.");
      }
    }

    if ([idxProntuarioPresc, idxDataInicioPresc, idxDosePresc, idxPesoRefPresc, idxTaxaPresc].includes(-1)) {
      throw new Error("Uma ou mais colunas essenciais n√£o foram encontradas na aba '" + CONFIG.sheets.prescricao + "'. Verifique os cabe√ßalhos e a configura√ß√£o (CONFIG).");
    }

    // --- OTIMIZA√á√ÉO: Pr√©-carrega o mapa de pesos ---
    Logger.log("Criando mapa de pesos otimizado...");
    // For√ßa a cria√ß√£o do mapa de pesos antes do loop
    buildAndCacheWeightMap(true); // O 'true' for√ßa a reconstru√ß√£o
    Logger.log("Mapa de pesos criado.");

    let linhasCalculadas = 0;
    let errosCalculo = [];
    const dadosAtualizadosPresc = []; // Array para armazenar os dados atualizados para a aba Prescri√ß√£o
    dadosAtualizadosPresc.push(cabecalhosPresc); // Mant√©m o cabe√ßalho

    // --- M√ìDULO 3: C√°lculo de Taxa (Itera√ß√£o e C√°lculo) ---
    Logger.log("Iniciando c√°lculo de taxas...");
    for (let i = 1; i < prescricaoData.length; i++) {
      const linhaOriginal = prescricaoData[i];
      const linhaNum = i + 1;
      const linhaAtualizada = linhaOriginal.slice(); // Cria uma c√≥pia para modificar

      const prontuario = String(linhaOriginal[idxProntuarioPresc]).trim();
      const dose = linhaOriginal[idxDosePresc];
      let dataInicio;

      // Valida√ß√µes b√°sicas
      if (!prontuario) {
        errosCalculo.push(`Linha ${linhaNum} (Prescri√ß√£o): Prontu√°rio vazio.`);
        linhaAtualizada[idxTaxaPresc] = "Falta Pront.";
        dadosAtualizadosPresc.push(linhaAtualizada);
        continue;
      }
      if (typeof dose !== 'number' || isNaN(dose)) {
        // N√£o √© um erro se a dose estiver vazia, apenas pula o c√°lculo
        if (dose !== "") {
            errosCalculo.push(`Linha ${linhaNum} (Prescri√ß√£o): Dose inv√°lida ('${dose}')`);
            linhaAtualizada[idxTaxaPresc] = "Erro Dose";
        }
        dadosAtualizadosPresc.push(linhaAtualizada);
        continue;
      }
      try {
        const dataValor = linhaOriginal[idxDataInicioPresc];
        if (!dataValor) throw new Error("vazia");
        dataInicio = new Date(dataValor);
        if (isNaN(dataInicio.getTime())) throw new Error("inv√°lida: " + dataValor);
      } catch (err) {
        errosCalculo.push("Linha " + linhaNum + " (Prescri√ß√£o): Data de in√≠cio " + err.message + ".");
        linhaAtualizada[idxTaxaPresc] = "Erro Data";
        dadosAtualizadosPresc.push(linhaAtualizada);
        continue;
      }

      // --- Usa a fun√ß√£o OTIMIZADA ---
      const pesoMaisRecente = findLatestWeightOptimized(prontuario, dataInicio);
      if (pesoMaisRecente !== null && typeof pesoMaisRecente === 'number' && pesoMaisRecente > 0) {
        const taxaCalculada = dose / pesoMaisRecente;
        linhaAtualizada[idxPesoRefPresc] = pesoMaisRecente;
        linhaAtualizada[idxTaxaPresc] = taxaCalculada;
        linhasCalculadas++;
      } else {
        // Se a taxa j√° existe (e √© um n√∫mero), mant√©m. Sen√£o, marca como "Peso n√£o encontrado".
        if (typeof linhaOriginal[idxTaxaPresc] !== 'number') {
          linhaAtualizada[idxTaxaPresc] = "Peso n√£o encontrado";
        }
        linhaAtualizada[idxPesoRefPresc] = ""; // Limpa o peso de refer√™ncia
      }
      dadosAtualizadosPresc.push(linhaAtualizada); // Adiciona a linha (atualizada ou n√£o)
    }
    Logger.log(`${linhasCalculadas} taxas calculadas/recalculadas.`);
    // --- Atualiza a planilha de Prescri√ß√µes com as novas taxas e pesos ---
    if (linhasCalculadas > 0 || errosCalculo.length > 0) { // Atualiza se houve c√°lculos ou erros a registrar
      Logger.log(`Atualizando aba '${CONFIG.sheets.prescricao}'...`);
      prescricaoSheet.getRange(1, 1, dadosAtualizadosPresc.length, dadosAtualizadosPresc[0].length).setValues(dadosAtualizadosPresc);
      // Reaplicar formata√ß√£o num√©rica
      prescricaoSheet.getRange(2, idxPesoRefPresc + 1, dadosAtualizadosPresc.length - 1, 1).setNumberFormat("0.000");
      prescricaoSheet.getRange(2, idxTaxaPresc + 1, dadosAtualizadosPresc.length - 1, 1).setNumberFormat("0.00");
      SpreadsheetApp.flush();
      Logger.log("Atualiza√ß√£o da aba de prescri√ß√£o conclu√≠da.");
    } else {
      Logger.log("Nenhuma taxa precisou ser calculada/atualizada na aba 'Prescri√ß√£o de Doses'.");
    }


    // --- M√ìDULO 4: An√°lise de Protocolo (executado ap√≥s calcular todas as taxas) ---
    // Usa os dados que acabamos de montar (dadosAtualizadosPresc)
    const dadosParaTabela = {}; // Armazena a √öLTIMA an√°lise por prontu√°rio

    // Ordena os dados de prescri√ß√£o por prontu√°rio e data
    const dadosPrescricaoOrdenados = dadosAtualizadosPresc.slice(1) // Ignora cabe√ßalho
      .filter(linha => linha[idxProntuarioPresc] && linha[idxDataInicioPresc]) // Filtra linhas sem prontu√°rio ou data v√°lida
      .sort((a, b) => {
        const prontA = String(a[idxProntuarioPresc]).trim();
        const prontB = String(b[idxProntuarioPresc]).trim();
        if (prontA < prontB) return -1;
        if (prontA > prontB) return 1;
        try {
          const dateA = new Date(a[idxDataInicioPresc]);
          const dateB = new Date(b[idxDataInicioPresc]);
          if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
            return dateA - dateB;
          }
        } catch (e) { /* Ignora erro de data inv√°lida na ordena√ß√£o */ }
        return 0;
      });
    let taxaAnterior = null;
    let prontuarioAtual = null;

    Logger.log("Iniciando an√°lise de mudan√ßa de dose...");
    for (let i = 0; i < dadosPrescricaoOrdenados.length; i++) {
      const linha = dadosPrescricaoOrdenados[i];
      const prontuario = String(linha[idxProntuarioPresc]).trim();
      const taxaCalculada = (typeof linha[idxTaxaPresc] === 'number' && !isNaN(linha[idxTaxaPresc])) ? linha[idxTaxaPresc] : null;
      let analiseResultado = "Inv√°lido"; // Padr√£o

      if (prontuario !== prontuarioAtual) { // Mudou de paciente
        taxaAnterior = null; // Reseta a taxa anterior
        prontuarioAtual = prontuario;
        if (taxaCalculada !== null) {
          analiseResultado = "Dose Inicial";
          taxaAnterior = taxaCalculada; // Define a primeira taxa v√°lida como refer√™ncia
        }
      } else { // Mesmo paciente
        if (taxaCalculada !== null) {
          if (taxaAnterior === null) {
            analiseResultado = "Dose Inicial (ou peso ausente antes)";
            taxaAnterior = taxaCalculada; // Define como a nova refer√™ncia
          } else if (Math.abs(taxaCalculada - taxaAnterior) < 0.01) {
            analiseResultado = "Manteve";
            // N√£o atualiza taxaAnterior, pois a taxa √© a mesma
          } else if (taxaCalculada > taxaAnterior) {
            analiseResultado = "Aumento";
            taxaAnterior = taxaCalculada; // Atualiza para a pr√≥xima compara√ß√£o
          } else { // taxaCalculada < taxaAnterior
            analiseResultado = "Redu√ß√£o";
            taxaAnterior = taxaCalculada; // Atualiza para a pr√≥xima compara√ß√£o
          }
        } else {
          analiseResultado = "Inv√°lido (sem taxa)"; // Taxa atual √© inv√°lida
        }
      }

      // Armazena a √öLTIMA an√°lise V√ÅLIDA para este paciente
      if (prontuario && analiseResultado.indexOf("Inv√°lido") === -1) {
        dadosParaTabela[prontuario] = analiseResultado;
      }
    }
    Logger.log("An√°lise de mudan√ßa de dose conclu√≠da. √öltimo status para " + Object.keys(dadosParaTabela).length + " pacientes.");
    // --- Atualizar a aba 'Tabela' com a √öLTIMA an√°lise de cada paciente ---
    let updatesTabela = 0;
    if (tabelaResumoSheet && idxProntuarioTabela !== -1 && idxAnaliseTabela !== -1) {
      Logger.log("Atualizando coluna '" + CONFIG.headers.analiseClassificacao + "' na aba 'Tabela'...");
      const rangeAnalise = tabelaResumoSheet.getRange(2, idxAnaliseTabela + 1, tabelaResumoSheet.getLastRow() - 1, 1);
      const valoresAtuaisAnalise = rangeAnalise.getValues();
      const novosValoresAnalise = [];
      for (let i = 1; i < tabelaResumoData.length; i++) { // Percorre a aba Tabela
        const prontuarioTabela = String(tabelaResumoData[i][idxProntuarioTabela]).trim();
        let valorFinal = (valoresAtuaisAnalise[i - 1] && valoresAtuaisAnalise[i - 1][0]) ? valoresAtuaisAnalise[i-1][0] : ""; // Valor atual por padr√£o

        if (prontuarioTabela && prontuarioTabela in dadosParaTabela) {
          const ultimoStatus = dadosParaTabela[prontuarioTabela];
          if (valorFinal !== ultimoStatus) { // Atualiza apenas se mudou
            valorFinal = ultimoStatus;
            updatesTabela++;
          }
        }
        novosValoresAnalise.push([valorFinal]); // Adiciona o valor (atual ou novo)
      }

      if (updatesTabela > 0) {
        rangeAnalise.setValues(novosValoresAnalise);
        Logger.log(updatesTabela + " linhas atualizadas na coluna '" + CONFIG.headers.analiseClassificacao + "' da aba 'Tabela'.");
      } else {
        Logger.log("Nenhuma atualiza√ß√£o necess√°ria na coluna '" + CONFIG.headers.analiseClassificacao + "' da aba 'Tabela'.");
      }
    }

    // --- Finaliza√ß√£o ---
    let mensagemFinal = `${linhasCalculadas} taxa(s) mg/kg foram calculadas/atualizadas na aba '${CONFIG.sheets.prescricao}'.\n`;
    mensagemFinal += `${updatesTabela} linha(s) tiveram a coluna '${CONFIG.headers.analiseClassificacao}' atualizada na aba '${CONFIG.sheets.tabelaResumo}' com o √∫ltimo status de dose.`;
    if (errosCalculo.length > 0) {
      mensagemFinal += '\n\nAten√ß√£o: Ocorreram ' + errosCalculo.length + ' erro(s) durante o c√°lculo de taxas (verificar logs para detalhes):\n' + errosCalculo.slice(0, 5).join('\n');
      if (errosCalculo.length > 5) mensagemFinal += '\n... e mais ' + (errosCalculo.length - 5) + ' erros.';
      Logger.log("Erros encontrados durante o processamento de taxas: " + JSON.stringify(errosCalculo));
    }

    // Tenta fechar o modal
    try { ui.showModalDialog(HtmlService.createHtmlOutput("<script>google.script.host.close();</script>").setHeight(10).setWidth(10), "Fechando..."); Utilities.sleep(500); } catch (e) { }

    ui.alert('Processamento Conclu√≠do!', mensagemFinal, ui.ButtonSet.OK);
  } catch (err) {
    Logger.log("Erro durante processarPlanilhaInteira: " + err + "\nStack: " + err.stack);
    try { ui.showModalDialog(HtmlService.createHtmlOutput("<script>google.script.host.close();</script>").setHeight(10).setWidth(10), "Fechando..."); Utilities.sleep(500); } catch (e) { }
    ui.alert('Erro no Processamento', 'Ocorreu um erro: ' + err.message + '. Verifique os logs (Extens√µes > Apps Script > Execu√ß√µes).', ui.ButtonSet.OK);
  } finally {
    lock.releaseLock(); // Libera o bloqueio
    Logger.log("Bloqueio de processamento liberado.");
  }
}


// --- M√ìDULO 5: OTIMIZA√á√ÉO DE PESO (CACHE) ---
// (Este m√≥dulo permanece inalterado)

/**
 * Cria um mapa de {prontu√°rio: [[data, peso], [data, peso], ...]}
 * onde a lista de pesos de cada paciente √© ORDENADA PELA DATA (mais recente primeiro).
 * Armazena este mapa no CacheService.
 * @param {boolean} force - Se true, for√ßa a reconstru√ß√£o do cache.
 */
function buildAndCacheWeightMap(force = false) {
  const cache = CacheService.getScriptCache();
  const CACHE_KEY = 'WEIGHT_MAP';
  if (!force) {
    const cachedMap = cache.get(CACHE_KEY);
    if (cachedMap) {
      Logger.log("Usando mapa de pesos do cache.");
      return JSON.parse(cachedMap);
    }
  }

  Logger.log("Construindo novo mapa de pesos...");
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const pesoSheet = ss.getSheetByName(CONFIG.sheets.peso);
  if (!pesoSheet) {
    Logger.log("Aba 'Registro de Peso' n√£o encontrada. N√£o √© poss√≠vel construir o mapa.");
    return {}; // Retorna objeto vazio
  }

  const pesoData = pesoSheet.getDataRange().getValues();
  const cabecalhosPeso = pesoData.shift(); // Remove cabe√ßalho
  const idxProntuarioPeso = cabecalhosPeso.indexOf(CONFIG.headers.prontuario);
  const idxDataPeso = cabecalhosPeso.indexOf(CONFIG.headers.dataPeso);
  const idxPeso = cabecalhosPeso.indexOf(CONFIG.headers.peso);
  if (idxProntuarioPeso === -1 || idxDataPeso === -1 || idxPeso === -1) {
    Logger.log("Aviso em buildAndCacheWeightMap: Cabe√ßalhos faltando na aba 'Registro de Peso'.");
    return {}; // Retorna objeto vazio
  }

  const weightMap = {};
  for (const linha of pesoData) {
    const prontuario = String(linha[idxProntuarioPeso]).trim();
    if (!prontuario) continue;

    const peso = linha[idxPeso];
    if (typeof peso !== 'number' || isNaN(peso) || peso <= 0) continue;

    let data;
    try {
      const dataValor = linha[idxDataPeso];
      if (!dataValor) continue;
      data = new Date(dataValor);
      if (isNaN(data.getTime())) {
        if (typeof dataValor === 'string' && dataValor.includes('/')) {
            const parts = dataValor.split('/');
            if (parts.length === 3) data = new Date(parts[2], parseInt(parts[1]) - 1, parts[0]); // Assume DD/MM/YYYY
        }
      }
      if (isNaN(data.getTime())) continue; // Pula se ainda for inv√°lida
    } catch (e) {
      continue; // Pula linha com data inv√°lida
    }

    if (!weightMap[prontuario]) {
      weightMap[prontuario] = [];
    }
    // Armazena como [timestamp, peso] para ordena√ß√£o num√©rica f√°cil
    weightMap[prontuario].push([data.getTime(), peso]);
  }

  // Ordena a lista de pesos de cada paciente (mais recente primeiro)
  for (const prontuario in weightMap) {
    weightMap[prontuario].sort((a, b) => b[0] - a[0]); // Ordena por timestamp, descendente
  }

  // Armazena no cache por 1 hora (3600 segundos)
  cache.put(CACHE_KEY, JSON.stringify(weightMap), 3600);
  Logger.log("Mapa de pesos constru√≠do e salvo no cache.");
  return weightMap;
}

/**
 * FUN√á√ÉO AJUDANTE OTIMIZADA
 * Encontra o peso mais recente para um paciente usando o mapa em cache.
 * @param {string} prontuario O prontu√°rio do paciente.
 * @param {Date} dataAlvo A data da prescri√ß√£o/administra√ß√£o.
 * @return {number|null} O peso mais recente ou null se n√£o encontrado/erro.
 */
function findLatestWeightOptimized(prontuario, dataAlvo) {
  const weightMap = buildAndCacheWeightMap(false); // Usa o cache se dispon√≠vel
  prontuario = String(prontuario).trim();
  if (!weightMap[prontuario]) {
    // Logger.log(`findLatestWeightOptimized: Nenhum peso registrado para ${prontuario}.`);
    return null;
  }

  const pesosDoPaciente = weightMap[prontuario]; // J√° est√° ordenado [data_desc, peso]
  const dataAlvoTime = dataAlvo.getTime();
  // Encontra o primeiro peso cuja data √© MENOR OU IGUAL √† data alvo
  for (const [dataTime, peso] of pesosDoPaciente) {
    if (dataTime <= dataAlvoTime) {
      // Logger.log(`findLatestWeightOptimized: Peso encontrado para ${prontuario} em ${new Date(dataTime).toLocaleDateString()}: ${peso}`);
      return peso;
    }
  }

  // Logger.log(`findLatestWeightOptimized: Nenhum peso encontrado para ${prontuario} EM OU ANTES de ${dataAlvo.toLocaleDateString()}.`);
  return null;
}

/**
 * =============================================================
 * M√ìDULO 6 (v2): CONSTRUTOR DE RELAT√ìRIO MODULAR
 * =============================================================
 */

/**
 * Abre o novo pop-up "Construtor de Relat√≥rios".
 */
function abrirModalRelatorioBuilder() {
  const html = HtmlService.createHtmlOutputFromFile('RelatorioBuilder')
    .setWidth(550)
    .setHeight(450);
  SpreadsheetApp.getUi().showModalDialog(html, 'Construtor de Relat√≥rio');
}

/**
 * =============================================================
 * M√ìDULO 6 (v3): CONSTRUTOR DE RELAT√ìRIO MODULAR (Corre√ß√£o de Linhas Vazias)
 * =============================================================
 */

/**
 * Abre o novo pop-up "Construtor de Relat√≥rios".
 * (Esta fun√ß√£o permanece igual)
 */
function abrirModalRelatorioBuilder() {
  const html = HtmlService.createHtmlOutputFromFile('RelatorioBuilder')
    .setWidth(550)
    .setHeight(450);
  SpreadsheetApp.getUi().showModalDialog(html, 'Construtor de Relat√≥rio');
}

/**
 * Fun√ß√£o principal do "Construtor de Relat√≥rios".
 * === ATUALIZADA (v3) para ignorar linhas vazias ===
 * @param {string[]} modulosSelecionados - Array de strings, ex: ["contagemSexo", "custoPorSexo"]
 */
function gerarRelatorioModular(modulosSelecionados) {
  const ui = SpreadsheetApp.getUi();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  
  // --- 1. Preparar a Aba de Relat√≥rio ---
  const nomeRelatorio = "Relat√≥rio Modular";
  let reportSheet = ss.getSheetByName(nomeRelatorio);
  if (reportSheet) {
    reportSheet.clear();
  } else {
    reportSheet = ss.insertSheet(nomeRelatorio);
  }
  ss.setActiveSheet(reportSheet);
  
  reportSheet.getRange("B1").setValue("Relat√≥rio Modular Gerado em: " + new Date().toLocaleString())
      .setFontWeight("bold").setFontSize(14);
  
  // --- 2. Ler os Dados da 'Tabela' (Uma √∫nica vez) ---
  const tabelaSheet = ss.getSheetByName(CONFIG.sheets.tabelaResumo);
  if (!tabelaSheet) {
    throw new Error("Aba '" + CONFIG.sheets.tabelaResumo + "' n√£o encontrada.");
  }
  const tabelaRange = tabelaSheet.getDataRange();
  const tabelaData = tabelaRange.getValues();
  const tabelaHeaders = tabelaData.shift(); // Pega cabe√ßalhos

  // --- CORRE√á√ÉO: Pegar o √≠ndice do Prontu√°rio AQUI ---
  const idxProntuario = tabelaHeaders.indexOf(CONFIG.headers.prontuario);
  if (idxProntuario === -1) {
    throw new Error("Coluna '" + CONFIG.headers.prontuario + "' n√£o encontrada na aba 'Tabela'. O relat√≥rio n√£o pode continuar.");
  }
  // --- FIM DA CORRE√á√ÉO ---

  let currentRow = 4; // Linha inicial para os gr√°ficos
  const chartWidth = 550;
  const chartHeight = 300;
  let erros = []; // Armazena avisos de m√≥dulos pulados

  // --- 3. Roteador de M√≥dulos ---
  
  // --- M√ìDULO: Contagem por Sexo ---
  if (modulosSelecionados.includes("contagemSexo")) {
    Logger.log("Tentando gerar 'contagemSexo'...");
    const idxSexo = tabelaHeaders.indexOf(CONFIG.headers.sexo);
    
    if (idxSexo === -1) {
      erros.push("M√≥dulo 'Contagem por Sexo' pulado: Coluna '" + CONFIG.headers.sexo + "' n√£o encontrada.");
    } else {
      const contagem = {};
      tabelaData.forEach(row => {
        // --- CORRE√á√ÉO AQUI ---
        const prontuario = row[idxProntuario];
        if (!prontuario) return; // Pula linha vazia
        // --- FIM DA CORRE√á√ÉO ---
        
        const sexo = row[idxSexo] || "N/D";
        contagem[sexo] = (contagem[sexo] || 0) + 1;
      });
      
      const dadosGrafico = [["Sexo", "Contagem"]];
      Object.keys(contagem).forEach(key => dadosGrafico.push([key, contagem[key]]));

      if (dadosGrafico.length > 1) {
        currentRow = gerarGrafico_(reportSheet, "Distribui√ß√£o por Sexo", Charts.ChartType.PIE, dadosGrafico, currentRow, chartWidth, chartHeight);
      }
    }
  }
  
  // --- M√ìDULO: Contagem por Prematuridade ---
  if (modulosSelecionados.includes("contagemPrematuridade")) {
     Logger.log("Tentando gerar 'contagemPrematuridade'...");
     const idxGestacao = tabelaHeaders.indexOf(CONFIG.headers.gestacao); 
     
     if (idxGestacao === -1) {
       erros.push("M√≥dulo 'Contagem por Prematuridade' pulado: Coluna '" + CONFIG.headers.gestacao + "' n√£o encontrada.");
     } else {
       const contagem = {};
       tabelaData.forEach(row => {
         // --- CORRE√á√ÉO AQUI ---
         const prontuario = row[idxProntuario];
         if (!prontuario) return; // Pula linha vazia
         // --- FIM DA CORRE√á√ÉO ---
         
         const gestacaoStr = String(row[idxGestacao] || "N/D").toLowerCase();
         let classificacao = "Padr√£o/Outro";
         if (gestacaoStr.includes("prematuro")) classificacao = "Prematuro";
         else if (gestacaoStr.includes("termo")) classificacao = "A Termo";
         
         contagem[classificacao] = (contagem[classificacao] || 0) + 1;
       });
       
       const dadosGrafico = [["Classifica√ß√£o", "Contagem"]];
       Object.keys(contagem).forEach(key => dadosGrafico.push([key, contagem[key]]));
       
       if (dadosGrafico.length > 1) {
         currentRow = gerarGrafico_(reportSheet, "Distribui√ß√£o por Prematuridade", Charts.ChartType.PIE, dadosGrafico, currentRow, chartWidth, chartHeight);
       }
     }
  }

  // --- M√ìDULO: Custo por Sexo ---
  if (modulosSelecionados.includes("custoPorSexo")) {
     Logger.log("Tentando gerar 'custoPorSexo'...");
     const idxCusto = tabelaHeaders.indexOf(CONFIG.headers.custoTotal);
     const idxSexo = tabelaHeaders.indexOf(CONFIG.headers.sexo);
     
     if (idxCusto === -1 || idxSexo === -1) {
       erros.push("M√≥dulo 'Custo por Sexo' pulado: Coluna '" + CONFIG.headers.custoTotal + "' ou '" + CONFIG.headers.sexo + "' n√£o encontrada.");
     } else {
       const agregador = {}; 
       tabelaData.forEach(row => {
          // --- CORRE√á√ÉO AQUI ---
          const prontuario = row[idxProntuario];
          if (!prontuario) return; // Pula linha vazia
          // --- FIM DA CORRE√á√ÉO ---

          const sexo = row[idxSexo] || "N/D";
          const custo = parseFloat(String(row[idxCusto]).replace("R$", "").replace(/\./g, "").replace(",", "."));
          if (isNaN(custo)) return;
          
          if (!agregador[sexo]) agregador[sexo] = { soma: 0, n: 0 };
          agregador[sexo].soma += custo;
          agregador[sexo].n++;
       });
       
       const dadosGrafico = [["Sexo", "Custo M√©dio (R$)"]];
       Object.keys(agregador).forEach(sexo => {
          const media = agregador[sexo].soma / agregador[sexo].n;
          dadosGrafico.push([sexo, media]);
       });
       
       if (dadosGrafico.length > 1) {
         currentRow = gerarGrafico_(reportSheet, "Custo M√©dio por Sexo", Charts.ChartType.COLUMN, dadosGrafico, currentRow, chartWidth, chartHeight);
       }
     }
  }
  
  // (Voc√™ pode adicionar mais m√≥dulos, como "duracaoPorPrematuridade", seguindo o mesmo padr√£o)

  // --- 4. Finaliza√ß√£o ---
  let msgFinal = `Relat√≥rio modular gerado com ${modulosSelecionados.length} m√≥dulo(s) solicitado(s).`;
  if (erros.length > 0) {
    msgFinal += "\n\nAvisos:\n" + erros.join('\n');
    Logger.log("Erros/Avisos do relat√≥rio modular: " + erros.join(', '));
  }
  
  ui.alert("Sucesso!", msgFinal, ui.ButtonSet.OK);
  return "Sucesso";
}


/**
 * HELPER: Fun√ß√£o gen√©rica para criar e inserir um gr√°fico na aba.
 * (Esta fun√ß√£o permanece igual)
 */
function gerarGrafico_(sheet, titulo, tipo, dados, linha, largura, altura) {
  try {
    // Insere T√≠tulo do Gr√°fico
    sheet.getRange(linha, 2).setValue(titulo).setFontWeight("bold").setFontSize(12);
    linha++;
    
    // Insere Tabela de Dados (√∫til para refer√™ncia)
    const dataRange = sheet.getRange(linha, 2, dados.length, dados[0].length);
    dataRange.setValues(dados);

    // Constr√≥i o Gr√°fico
    const chartBuilder = sheet.newChart()
      .setChartType(tipo)
      .addRange(dataRange)
      .setOption('title', titulo)
      .setOption('width', largura)
      .setOption('height', altura)
      .setPosition(linha, 4, 0, 0); // Posi√ß√£o: linha atual, coluna D (4)

    if (tipo === Charts.ChartType.PIE) {
      chartBuilder.setOption('pieHole', 0.4);
    }
    
    sheet.insertChart(chartBuilder.build());
    
    // Calcula nova linha
    const approxChartRows = Math.ceil(altura / 21) + 1; // Altura da linha padr√£o √© ~21px
    return linha + approxChartRows + 2; // Retorna a pr√≥xima linha livre

  } catch (e) {
    Logger.log("Erro ao gerar gr√°fico '" + titulo + "': " + e.message);
    sheet.getRange(linha, 2).setValue("Erro ao gerar gr√°fico: " + e.message);
    return linha + 3; // Pula algumas linhas
  }
}

/**
 * =============================================================
 * FUN√á√ÉO DE TESTE (Pode apagar depois)
 * Usada APENAS para for√ßar o pedido de permiss√£o para 'openById'.
 * =============================================================
 */
function testarPermissaoBancoMestre() {
  try {
    Logger.log("Tentando conectar ao Banco de Dados Mestre...");
    // (MASTER_DB_SHEET_ID √© a const global que voc√™ moveu para c√°)
    const db = SpreadsheetApp.openById(MASTER_DB_SHEET_ID);
    Logger.log("Conectado com sucesso: " + db.getName());
    SpreadsheetApp.getUi().alert("Sucesso!", "Permiss√£o concedida para acessar o Banco de Dados Mestre.", SpreadsheetApp.getUi().ButtonSet.OK);
  } catch (e) {
    Logger.log("Erro ao testar permiss√£o: " + e.message);
    SpreadsheetApp.getUi().alert("Erro no Teste", e.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}